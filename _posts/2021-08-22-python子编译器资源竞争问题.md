---
published: true
layout: post
title: bpo-37224 python子编译器资源竞争问题
category: python
tags:
  - python
time: '2021.08.22 15:47:00'
excerpt: null
---
cpython MR门禁中偶现的一个失败用例问题修复过程记录 

<!--more-->

## 问题背景介绍
这个问题是cpython项目门禁中发现的一个问题，具体的表现就是子编译器相关的两个用例（`test_still_running`, `test_already_running`，[用例代码详情](https://github.com/python/cpython/blob/main/Lib/test/test__xxsubinterpreters.py#L843-L846)）会高概率出现失败，尤其是并行测试数量多于300时，基本在10小时内就能再次捕捉到相关错误。[问题单详情](https://bugs.python.org/issue37224)

此问题可以用`./python -m test test__xxsubinterpreters -v -F -j300`来执行并捕捉相关错误。
错误输出日志为：
```python
test_already_running (test.test__xxsubinterpreters.RunStringTests) ... FAIL

======================================================================
FAIL: test_already_running (test.test__xxsubinterpreters.RunStringTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/shihai/cpython/Lib/test/test__xxsubinterpreters.py", line 834, in test_already_running
    with self.assertRaises(RuntimeError):
AssertionError: RuntimeError not raised

----------------------------------------------------------------------

Ran 123 tests in 71.761s

FAILED (failures=1, skipped=6)
Warning -- Uncaught thread exception: RuntimeError
Exception in thread Thread-8 (run):
Traceback (most recent call last):
  File "/home/shihai/cpython/Lib/threading.py", line 1009, in _bootstrap_inner
    self.run()
    ^^^^^^^^^^
  File "/home/shihai/cpython/Lib/threading.py", line 946, in run
    self._target(*self._args, **self._kwargs)
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/shihai/cpython/Lib/test/test__xxsubinterpreters.py", line 48, in run
    interpreters.run_string(interp, dedent(f"""
RuntimeError: unrecognized interpreter ID 60
test test__xxsubinterpreters failed
```

### 定位过程梳理
1.线程未及时获取GIL锁导致
上面的错误日志中可以看到的是interpreter ID 60未找到，当时的第一反应是thread线程没有获取到GIL，导致C层面的线程在测试用例完成测试并清理完interpreter ID 60导致的。

为什么我会提出这个可能性呢？因为`./python -m test test__xxsubinterpreters -v -F -j300`的300并发量是通过启用线程来实现的。基于这点的考虑我想如果能在thread过程能引入一个锁来确保thread是及时获取GIL并运行的。因此我提了[PR-26598](https://github.com/python/cpython/pull/26598)想解决这个问题。我用这个PR来运行原有的失败测试时有13小时没有复现此问题，就暗自庆幸解决了这个问题。但是这个PR一提出来就被Pablo Galindo Salgado质疑此PR的有效性。

因此我继续回到本地环境重新执行测试用例监控，结果在19小时的时候继续捕捉到了此问题。所以PR-26598没有彻底解决此问题，但是延长了偶现出现的时间间隔。这个PR也从侧面否定了这个推测是错误的。

为什么这个推测是错误的？因为`j300`虽然开始是启动了300个线程来触发并发量，但实际thread线程运行过程中是用subprocess来执行测试用例([单元测试的核心触发逻辑请点击这里](https://github.com/python/cpython/blob/main/Lib/test/libregrtest/runtest_mp.py#L55))，如果测试用例都用进程来隔离了，那GIL就不会彼此相互影响了。

2.python代码在ceval过程执行字节码过程中跳过因为某种资源竞争跳过了字节码的执行(用`./python -m dis ./Lib/test/test__xxsubinterpreters.py`来分析自编译器相关代码对应的字节码序列)。
```python
Disassembly of <code object test_already_running at 0x7faf152bc190, file "./Lib/test/test__xxsubinterpreters.py", line 838>:
839           0 LOAD_GLOBAL              0 (_running)
              2 LOAD_FAST                0 (self)
              4 LOAD_ATTR                1 (id)
              6 CALL_FUNCTION            1
              8 SETUP_WITH              72 (to 82)
             10 POP_TOP

840          12 LOAD_FAST                0 (self)
             14 LOAD_METHOD              2 (assertRaises)
             16 LOAD_GLOBAL              3 (RuntimeError)
             18 CALL_METHOD              1
             20 SETUP_WITH              30 (to 52)
             22 POP_TOP

841          24 LOAD_GLOBAL              4 (interpreters)
             26 LOAD_METHOD              5 (run_string)
             28 LOAD_FAST                0 (self)
             30 LOAD_ATTR                1 (id)
             32 LOAD_CONST               1 ('print("spam")')
             34 CALL_METHOD              2
             36 POP_TOP
             38 POP_BLOCK
             40 LOAD_CONST               0 (None)
             42 DUP_TOP
             44 DUP_TOP
             46 CALL_FUNCTION            3
             48 POP_TOP
             50 JUMP_FORWARD            16 (to 68)
        >>   52 WITH_EXCEPT_START
             54 POP_JUMP_IF_TRUE        58
             56 RERAISE
        >>   58 POP_TOP
             60 POP_TOP
             62 POP_TOP
             64 POP_EXCEPT
             66 POP_TOP
        >>   68 POP_BLOCK
             70 LOAD_CONST               0 (None)
             72 DUP_TOP
             74 DUP_TOP
             76 CALL_FUNCTION            3
             78 POP_TOP
             80 JUMP_FORWARD            16 (to 98)
        >>   82 WITH_EXCEPT_START
             84 POP_JUMP_IF_TRUE        88
             86 RERAISE
        >>   88 POP_TOP
             90 POP_TOP
             92 POP_TOP
             94 POP_EXCEPT
             96 POP_TOP
        >>   98 LOAD_CONST               0 (None)
            100 RETURN_VALUE
```

3.
