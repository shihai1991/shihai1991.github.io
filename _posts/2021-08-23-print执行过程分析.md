---
published: true
layout: post
title: python print执行过程分析
category: python
tags:
  - python
time: '2021.08.23 12:44:00'
excerpt: null
---
python print()函数在cpython内部的执行过程简单梳理。

<!--more-->

## 主要流程介绍
实际这个测试文件test.py就一行代码：print('Hello World!')。
```python
print('Hello World!')
```
相关的字节码为：
```
   1           0 LOAD_NAME                0 (print)
              2 LOAD_CONST               0 ('Hello World!')
              4 CALL_FUNCTION            1
              6 POP_TOP
              8 LOAD_CONST               1 (None)
             10 RETURN_VALUE

```
实际的主要函数调用逻辑图如下图所示，使用的cpython代码基线版本为v3.11。
![]({{site.baseurl}}/img/python print  flow.jpg)

## TODO
1. 还需要继续补充codeobject是如何生成的。
2. frameobject的生成过程（consts常量存储过程要着重说一下。）
3. 多个子编译器print('Hello World')过程又是如何的？

个py可能会生成多个codeobject，一个类一个，一个函数一个，一个模块一个，存放到codeobject.co_consts中，解释的时候根据代码控制流图的顺序执行
涉及多个codeObject时，如果是function的codeObject，会先make_function创建functionObject，在调用_PyFunction_Vectorcall()时重新创建frameobject，然后再调用_PyEval_EvalFrame()执行。

PyEval_EvalCode执行codeobject
PyEval_EvalFrameEx()遍历字节码指令序列，这个是主入口
eval_frame（_PyEval_EvalFrameDefault）挂在interpreter中，实际就是PyEval_EvalFrameEx()函数
pyc->PyCodeObject
python编译器真正执行的并不是PyCodeObject对象而是PyFrameObject(执行环境），比如print(i)，全局的i和局部的i值可能不一样，都保留在执行环境中。

const常量存储过程：从codeobject的co_consts中取出来先放到framework的stack_pointer上，然后在把具体的key，value从栈指针放到framework的locals中, co_consts是在编译代码块（code_block）的时候生成的，实际在compile.c中的assemble()和makecode()中封装成tupleObject。

Eval评估过程：ceval.c:PyEval_EvalFrameDefault()->case(MAKE_FUNCTION)->PyFunction_NewWithQualName()->op->vectorcall = _PyFunction_Vectorcall;->_PyFunction_Vectorcall()

_PyThread_CurrentFrames(): interpreter有tstate_head（有一系列tstate），每一个tstate都可能指向一个frame
往interpreter中挂tstate可以通过new_threadstate()来添加