---
published: true
layout: post
category: python
catalog: true
tags:
  - python
time: '2021.12.23 19:17:00'
---
> python支持并发/并行的手段主要是asyncio、threading以及multiprocessing。
> 我的测试虚拟机是4核虚拟机。

## asyncio
```python
import asyncio
import time


async def count(number):
    result = sum(i * i for i in range(number))
    return result


async def cacluate_count(numbers):
    tasks = [asyncio.create_task(count(number)) for number in numbers]
    result = await asyncio.gather(*tasks)


def main():
    begin_time = time.perf_counter()
    numbers = [1000000 + x for x in range(20)]
    asyncio.run(cacluate_count(numbers))
    end_time = time.perf_counter()
    print('Total cost time is: ', end_time -  begin_time)


if __name__ == '__main__':
    main()
```
结果输出是:`Total cost time is:  5.781235985457897`。（执行五次取得的中位数）

## threading
```
import  threading
import time


def count(number):
    result = sum(i * i for i in range(number))
    return result


def cacluate_count(numbers):
    threads = [threading.Thread(target=count, args=(number,)) for number in numbers]
    for thread in threads:
        thread.start()
    for thread in threads:
        thread.join()


def main():
    begin_time = time.perf_counter()
    numbers = [1000000 + x for x in range(20)]
    cacluate_count(numbers)
    end_time = time.perf_counter()
    print('Total cost time is: ', end_time -  begin_time)


if __name__ == '__main__':
    main()
```
结果输出是:`Total cost time is:  5.884195368736982`。（执行五次取得的中位数）

## multiprocessing
```
import multiprocessing
import time


def count(number):
    result = sum(i * i for i in range(number))
    return result


def cacluate_count(numbers):
    processes = [multiprocessing.Process(target=count, args=(number,)) for number in numbers]
    for process in processes:
        process.start()
    for process in processes:
        process.join()


def main():
    begin_time = time.perf_counter()
    numbers = [1000000 + x for x in range(20)]
    cacluate_count(numbers)
    end_time = time.perf_counter()
    print('Total cost time is: ', end_time -  begin_time)


if __name__ == '__main__':
    main()
```
结果输出是:`Total cost time is:  1.502054424956441`。


## threading+subinterpreters

## 总结
从上面测试结果看，在我的4核cpu虚拟机上，进程的效率大概是线程和协程的4倍，协程的效率略快于线程，主要原因是线程上下文切换和GIL锁获取的操作上。
