---
layout: post
title: 《代码大全》阅读随笔
category: books
catalog: true
published: true
tags:
  - books
time: '2022.06.01 15:52:00'
---
# 五、软件构建中的设计
## 5.1 设计中的挑战
设计就是把需求分析和编码调试连在一起的活动。

### 5.1.1 设计是一个险恶的问题
学校的编程任务是从头到尾直线前进而设计的。而社会中的编程开发需求可能在反复变动。
瀑布模式和敏捷模式本质区别在于**承认未来的需求是否会发生变化及发生变化的频率？**

### 5.1.2 设计是一个无章法的过程
你很难判断设计何时算是“足够好”了，设计到什么细节才算够？又有多少设计可以留到编码阶段时再做？
思考设计到自己没时间为止:)  
在用UML写设计图时，user case图等实际是一个设计结果，实际设计过程中可以用DDD模型中的用户旅程图、事件风暴、命令风暴来提取现实世界的逻辑关系在进行收敛、固化至相关UML设计图中。

## 5.2 关键的设计概念
### 5.2.1 管理复杂度的重要性
软件项目失败的原因很少是技术原因导致的，如果项目确实由技术原因导致时，其原因通常就是失控的复杂度。
### 5.2.2 理想的设计特征
- 最小的复杂度
- 易于维护
- 松散耦合
- 可扩展性
- 可重用性
- 高扇入：基础类应该尽可能多被使用，避免在高级类中重复造轮子；
- 低扇出：基础类应该尽量少的引用其他类，功能聚焦；
- 可移植性
- 精简性
- 层次性：如果你编写一个新系统用了设计不佳的旧代码，就需要写一个负责新旧系统交互层方便后续的重构；
- 标准技术：使用标准技术，降低团队其他成员的介入成本；

### 5.2.3 设计层次
- 软件系统
- 分解为子系统或包
- 分解为类
- 分解成子系统

## 5.3 设计构造块：启发式方法
软件设计是非确定性的，三个人可能有三种设计思路。

### 5.3.1 找出现实世界中的对象
首选且最流行的一种做法便是**面向对象设计方法**，此方法的要点是辨识现实世界中的对象以及人造对象。
使用对象进行设计的步骤是：
- 辨识对象及其属性（方法(method)和数据(data)）；
- 确定可以对各个对象进行的操作；
- 确定各个对象能对其他对象进行的操作；
- 确定对象的哪些部分对其他对象可见哪些不可以（public和private）;
- 定义每个对象的公共接口；

### 5.3.2 形成一致的抽象
抽象是一种能让你在关注某一概念的同时可以放心地忽略其中一些细节的能力--在不同的层次处理不同的细节。你把房子称为房子而不是由玻璃、木材、钉子构成的组合体时，你就是在用抽象了。以复杂度的观点看，抽象的主要好处就在于它使你能忽略无关的细节。

### 5.3.3 封装实现细节
抽象是你能从高层的细节来看待一个对象，而封装则是除此之外，你不能看到对象的任何其他细节层次。封装帮助你管理复杂度的方法是不让你看到那些复杂度。

### 5.3.4 当继承能简化设计时就继承
继承的好处是他能很好地辅佐抽象的概念。抽象是从不同层次来看对象的。门从属性上看可以是不同种类构成，如：木头、铁，从功能层面讲可以防盗。木头又有自己的属性，如可以被锯开或者用乳胶粘合。继承能简化编程的工作。

### 5.3.5 信息隐藏
信息隐藏主要有两大类：`隐藏复杂度`和`隐藏变化源`。一个例子，所有代码调用如下代码来获得ID：`id = ++max_id`，但后续很难对id做加强，最好方式是`隐藏`到`NewID()`函数中，如果后续对返回类型也可能做修改，返回类型最好也用宏定义做隐藏处理:`typdef IDType int`，隐藏设计决策可以减少`改动所影响的代码量`。请养成问"我该隐藏些什么"的习惯。

### 5.3.6 找出容易改变的区域
- 找出看起来容易变化的项目：如果需求做得好，那么其中就应该包含一份潜在变化清单，以及每一项变化的可能性；可以通过找程序中对用户最有用的最小子集来构成系统核心，然后用微小的步伐迭代扩充这个系统。
- 把容易变化的项目分离出来
- 把看起来容易变化的项目隔离开来
- 业务规则：业务规则很容易成为软件频繁变化的根源，所以最好使用"信息隐藏"原则隐藏相关信息；
- 输入和输出
- 非标准的语言特性
- 困难的设计区域和构建区域
- 状态变量
- 数据量的限制

### 5.3.7 保持松散耦合
尽量使你创建的模块不依赖或者少依赖其他模块。

#### 5.3.7.1 耦合标准
- 规模：函数中参数个数及对外的可见公用方法；
- 可见性：通过参数表显性传递模块间的调用关系；
- 灵活性：模块更容易被其他模块调用，那么他们之间的耦合关系就会越松散；

#### 5.3.7.2 耦合的种类
- 简单数据参数耦合
- 简单对象耦合
- 对象参数耦合：封装和信息隐藏不够好；
- 语义上的耦合：模块间知道彼此间的执行逻辑；

### 5.3.8 查阅常用的设计模式
设计模式通过把常见解决方案的细节予以制度化来减少出错，[常用设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)。

## 5.4 设计实践
自上而下的策略和自下而上策略的最关键区别在于前者时一种分解策略而后者是一种合成策略。前者从一般性的问题出发，把该问题分解成可控的部分。后者从可控的部分出发，去构造一个通用的方案。  
最大的设计失误来自于我误认为自己已经做得很充分，可事后却发现还是做得不够，没能发现其他一些设计挑战。  
有些项目因太过于专注对设计进行文档化而导致失败。（劣币驱逐良币原则）  
传统的记录设计成果的方式是把它写成正式的设计文档。然而，你还可以用很多种方法来记录这一成果，而这些方法对于那些小型的、非正式的项目或者只需要轻量级的记录设计成果的方式的项目而言效果都不错：
- 把设计文档插入到代码里；
- 用Wiki来记录设计讨论和决策；
- 写总结邮件；

# 八、防御式编程

## 8.3 错误处理技术

### 8.3.1 健壮性与正确性
人身安全攸关的软件往往更倾向于正确性而非健壮性，消费类应用软件往往更注重健壮性而非正确性。

# 二十四、重构
## 24.1 软件演化的类型
软件演化类型就像生物进化一样，有些突变对物种是有益的，另外一些则是有害的。区分软件演化类型的关键就是程序的质量在这一过程中是提高了还是降低了。另外软件演化在开发阶段还是维护阶段的演化表现也有差别，在开发阶段的演化更自由。

## 24.2 重构简介
在不改变软件外部行为的前提下对其内部结构进行改变，使之更容易理解并便于修改。

### 24.2.1 重构的理由
- 代码重复：DRY原则；
- 冗长的子程序
- 循环过长或嵌套过深
- 内聚性太差的类：如果某类包揽了许多彼此无关的任务，那么这个类可以拆分成多个类；
- 类的接口未能提供层次一致的抽象；
- 拥有太多参数的参数列表；
- 类的内部修改往往被局限于某个部分：如果你仅修改类中的一部分那么该类应该讲相互独立的功能被拆分成多个类；
- 变化导致对多个类的相同修改：如果发现自己常常对一组类进行修改，这表明这些类中的代码应当被重新组织，使修改仅影响到其中的一个类：
- 对继承体系的同样修改：
- case语句需要做相同的修改；
- 同时使用的相关数据并未以类的方式进行组织；
- 成员函数使用其他类的特征比使用自身类的特征还要多；
- 过多使用基础数据类型；
- 某个类无所事事：如果代码重构导致某个类无所事事，需要确认此类是否可以彻底去掉；
- 一系列传递流浪数据的子程序；
- 中间人对象无事可做：类中的绝大部分代码只是去调用其他类中的成员函数，需要确认是否可以去掉此类直接改为直接调用其他的类；
- 某个类同其他类关系过于亲密：如果一个类对另外类的了解超过了应该的程度那么就需要进行更强的封装；
- 子程序命名不当；
- 数据成员被设置为公用；
- 某个类仅使用了基类的很少一部分成员函数：这时可以考虑将派生类相对于基类的关系从“is-a”转变为“has-a”；


# 参考书籍
[代码大全（第2版）](https://book.douban.com/subject/1477390/)  
[High fan-in low fan-out](https://zhuanlan.zhihu.com/p/391411455)
