---
layout: post
title: CPython知识点简单梳理
category: cpython
catalog: true
published: true
tags:
  - cpython
time: '2022.12.10 23:47:00'
---
## 1.3 re.match和re.search区别
match是从第一个字符开始匹配

## 1.4 子类覆写掉外层调用方法，内层调用还是调用父类的原因是为啥？

## 1.5 python中的舍入算法
银行家舍入：4舍，5看奇偶：奇进偶舍

## 1.6 只有CPython的多线程才有GIL
Each Python process gets its own Python interpreter and memory space so the GIL won’t be a problem.


## 1.8 内置函数
- vars == __dict__: 当前类的属性字典
- dir(): 实例+基类属性
- locals(): 返回局部空间变量

## 1.9 魔法方法
### 1.9.1 __getattr__和__getattribute__的区别
先调用__getattribute__，不存在再调用__getattr__（用于处理不存在的值）
### 1.9.2 __getitem__用于集合类
### 1.9.3 getattr()可以获取具体类的值
### 1.9.4 __用来避免子类覆盖

## 1.10 function和method的区别
类调用function，实例调用method

## 1.11 装饰器装饰函数
装饰器初始化只会初始化一次

## 1.12 staticmethod和classmethod的区别
需要传入cls的是classmethod，不传入的是staticmethod

## 1.13 if语句判真逻辑
if [] 或者 if ''判断逻辑是不会判真的。

## 1.14 __init__()的使用
子类有则不会默认调用父类，子类没有则会默认调用父类

## 1.15 subprocess中的import是否和主进程import_modules隔离
是的，这是两个独立的内存空间和解释器

## 1.16 subprocess中import module会影响编译器级别的module管理？
发现不影响外部的进程

## 1.17 通过type()或者type.__new__()来创建类
X = type('X', (object,), dict(a=1))

## 1.18 __future__的基本使用
from __future__ import absolute_import的原因是避免有调用模块和系统库同名冲突

## 1.19 _和__的使用
_内部属性 __说明内部函数，子类无法继承 __xx__，表示魔术方法，类或者对象对于某些事件会自动触发

## 1.20 不可变对象
str、bytes、tuple均是不可变对象，list、dict、set均是可变对象，创建后无法被修改。bytes和str的`replace()`实际是创建了一个新的copy副本。看是不是不可变序列，看对象是否能修改，以及修改后的执行`id()`显示的内存地址是否发生改变，内存地址发生改变就是不可变对象。

## 1.21 id(__eq__)的执行逻辑
下面的代码输出`a`和`b`的id(__eq__)有点诡异，待确认。
```
>>> class A:
...     pass
...
>>> def b():
...     pass
...
>>> id(A.__eq__)
139834352387184
>>> id(b.__eq__)
139834332534160
>>> a = A()
>>> id(a.__eq__)
139834332529040
>>> id(a.__eq__)
139834332532240
>>> id(a.__eq__)
139834332529040
>>> id(a.__eq__)
139834332532240
>>> id(a.__eq__)
139834332529040
>>> id(b.__eq__)
139834332532240
>>> id(b.__eq__)
139834332529040
```

# 二、CPython实现逻辑
## 2.1 如何根据CPU配置进程并发数量？

## 2.2 子编译器如何共享module？在import里面有两个逻辑
### 2.2.1 从interp的modules中获取
一个走老的逻辑直接拿interp的modules，这个会导致还在用老的创建模块方式的模块无法加载进来

### 2.2.2 从spec中重新创建
子编译器是如何实现共用的，是在`_PyImport_FixupExtensionObject()`中会将`md_dict`放到def的`def->m_base.m_copy`中，然后切换到自编译上下文时，import操作会调用IMPORT_NAME，这个函数实际是会调用`PyImport_ImportModuleLevelObject()`，这个函数内判断如果子编译器没有加载module，就会调用import_find_and_load()加载模块，此函数会调用python级别的`importlib._find_and_load()`函数，此函数又会调用_imp.create_builtin（），这个函数在C层面会调用_imp_create_builtin()，这个函数里面主要是两层逻辑:
i. 如果spec已经在extensions中了（extensions的共享当前只在主编译器中处理，也是bpo-44050问题所在），则创建对应的module，并由m_copy来更新相关的md_dict；
ii. config.c里面有内置的模块，如果create_builtin是初始化相关内置模块则由此入口进，这里的初始化也是分为两种，一种是`PyModule_FromDefAndSpec()`，另外一种是用def.m_init进行初始化(`_PyImport_FixupExtensionObject()`)。
`testcapimodule.c`和`testinternalcapi.c`放在Makefile中生成，用`TEST_MODULE`来进行控制是否要生成此模块。

## 2.3 PyObject_GehitAttrString()函数内部实现原理
PyObject_GetAttrString()->PyObject_GetAttr()->
tp->getattro(): metatype= Type_Type; meta_attribute =_PyType_Lookup(Type_Type, __qualname__); 
实际上meta_attribute的父类是PyGetSetDescr_Type 
meta_get = Py_TYPE(meta_attribute)->tp_descr_get;
实际上meta_get是getset_get()
res = meta_get(meta_attribute, (PyObject *)type, (PyObject *)metatype);
type是要查询的类，metatype是type的父类
_PyType_Lookup(x)这个逻辑里面实际是在用mro在Type_Type.tp_dict里面用查找，tp_dict是在type_new里面传入进来的
这个实际tp_dict中为啥有各类的member属性，这个主要是type_new()->type_new_impl()->PyType_Ready()->type_ready()中进行初始化
->getset_get()
descr->d_getset->get()是type_qualname()
PyType_Type在Objects/object.c中的_PyTypes_Init()中被初始化。

## 2.4 PyObject_GetAttrString(t, "__qualname__")如何获取到__qualname__属性?

## 2.5 扩展模块的创建入口
扩展模块的创建入口在import.c中的``create_builtin``。

## 2.6 GIL锁
thread创建lock:
https://github.com/python/cpython/blob/master/Python/thread_nt.h#L269
thread申请获取lock：https://github.com/python/cpython/blob/master/Python/thread_nt.h#L336
创建thread执行时获取gil（这里会继续用vectorfun去调用）：
https://github.com/python/cpython/blob/master/Modules/_threadmodule.c#L1042
PyEval_AcquireThread(tstate);

## 2.7 const常量存储过程
从codeobject的co_consts中取出来先放到framework的stack_pointer上，然后在把具体的key，value从栈指针放到framework的locals中, co_consts是在编译代码块（code_block）的时候生成的，实际在compile.c中的assemble()和makecode()中封装成tupleObject。

## 2.8 Eval求值过程
ceval.c:PyEval_EvalFrameDefault()->case(MAKE_FUNCTION)->PyFunction_NewWithQualName()->op->vectorcall = _PyFunction_Vectorcall;->_PyFunction_Vectorcall()
_PyThread_CurrentFrames(): interpreter有tstate_head（有一系列tstate），每一个tstate都可能指向一个frame
往interpreter中挂tstate可以通过new_threadstate()来添加

## 2.9 PyEval_RestoreThread这个函数是干什么用的？

## 2.10 为什么说GIL是控制住thread把住字节码到interpreter的入口？
直接用fork开了一个
https://github.com/python/cpython/blob/master/Lib/multiprocessing/context.py#L224
最终是在这里调用：https://github.com/python/cpython/blob/master/Lib/multiprocessing/popen_fork.py#L62
multiprocessing是一个独立的编译器？

## 2.10 模块管理
### 2.10.1 堆类型管理
`PyType_FromSpec()`可以创建堆类型，但`PyType_FromModuleAndSpec()`可以将堆类型和模块关联起来。   
`TypeSpec`和`ModuleSpec`可以看做是堆类型和堆模块的某种父类。   
这里如果是遇到是`tp_add`这种函数槽要进行类型相加，就必须要对两个入参类型进行判断，问题是怎么判断是更加合适？
一种比较好的方式是直接在`Type_Spec`中多扩展一个指针属性可以指向自己本身，这样在用`tp_add`对堆类型做比较时就可以直接用`Type_Spec`的指针类型进行比较。

## 2.12 nm的使用
用nm可以看object files里面的symbols，用strip工具可以去除符号表

## 2.13 引用计算的释放顺序
释放内存先释放外层，再释放内层，避免悬挂指针

## 2.14 模块导入问题
xxx_toplevel()函数申明定义在frozen.c，实际自动生成是由freeze_modules.py来处理，deepfreeze.c是有
import __hello__或者import __phello_alias__，>> __hello__会发现模块输出的信息是会备注（frozen）信息
调用链可以用gdb -args ./python -c "import __hello__"然后在_Py_get___hello___toplevel打断点就进来了
deepfreeze.py生成deepfreeze.c

## 2.15 builtin模块的编译和导入
builtin module的编译在setup.py，初始化导入在import.c中的`create_builtin()`函数中，要导入的模块集合放到PyImport_Inittab数组中,此数组定义在Modules/config.c中

## 2.16 编译过程
通过词法解析将文本转换为`CST`，通过语法解析将CST转换为AST，通过`compile.c`中的`_PyAST_Compile()`将AST转换为`codeobject`。
**编译器(compiler)**:将`AST`转换为`codeobject`的过程。

## 2.17 测试引用泄露
./python -m test -R 3:3 test_importlib -vv

## 2.17 [PEP 630](https://peps.python.org/pep-0630)
### 2.17.1 [metaclass获取问题](https://peps.python.org/pep-0630/#metaclasses)
[问题的触发代码](https://github.com/CharlieZhao95/cpython/blob/42b20d517e5ca6d3f7a23fa43389eff7d972dae2/Modules/_datetimemodule.c#L3104)。当调用`nb_add`时，当模块切换到heap type时就可能无法检索到原来历史的module块信息，具体的原因是`nb_add`会传入两个object对象，我们无法确认那个heap type是此module创建出来的。   
用上面的分支代码构建后执行`./python -m test test_datetime -v`时，会发现用例出错。   
具体的报错信息为：
```shell
test_computations (test.datetimetester.TestSubclassDateTime_Fast) ... python: Objects/typeobject.c:3757: _PyType_GetModuleByDef: Assertion `_PyType_HasFeature((PyTypeObject *)type, (1UL << 9))' failed.
Fatal Python error: Aborted
```
实际执行的用例为：
```python
def test_computations(self):
   eq = self.assertEqual
   td = timedelta

   a = td(7) # One week
   b = td(0, 60) # One minute
   c = td(0, 0, 1000) # One millisecond
   eq(a+b+c, td(7, 60, 1000))
```
实际执行出错的代码在`_datemodule`模块的`delta_add()`函数。
```
static PyObject *
delta_add(PyObject *left, PyObject *right)
{
    PyObject *result = Py_NotImplemented;
    // 这行出错了，两个入参left，right无法确定哪个是datemodule创建出来的heap type。
    _datetimemodule_state *state = find_datetimemodule_state_by_type(Py_TYPE(left));

    if (PyDelta_Check(left, state) && PyDelta_Check(right, state)) {
        /* delta + delta */
        /* The C-level additions can't overflow because of the
         * invariant bounds.
         */
        int days = GET_TD_DAYS(left) + GET_TD_DAYS(right);
        int seconds = GET_TD_SECONDS(left) + GET_TD_SECONDS(right);
        int microseconds = GET_TD_MICROSECONDS(left) +
                           GET_TD_MICROSECONDS(right);
        _datetimemodule_state *state = find_datetimemodule_state_by_type(Py_TYPE(left));
        result = new_delta(days, seconds, microseconds, 1, state);
    }

    if (result == Py_NotImplemented)
        Py_INCREF(result);
    return result;
}
```

## 2.18 tp_methods、tp_members、tp_getset区别
tp_methods返回函数，tp_members返回类属性，tp_getset通过调用相关函数返回属性。

## 2.19 __annotations__
作用是什么？

# 三、博客待输出
这个可以写个解析题
```
float('inf')可以写个解析题float('inf') == float('inf') - 1
```
