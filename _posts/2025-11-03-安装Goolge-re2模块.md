---
layout: post
title: Python安装Google-re2模块
category: python
catalog: true
published: false
tags:
  - python
time: '2025.11.03 19:13:00'
---

# 一、背景
介绍在centos下安装`re2`首先需要安装依赖的`C++17 编译器`和`Abseil库`。

## C++17
要确保你的GCC版本是7.x以上即可支持C++17。GCC安装可以通过源码安装。
```shell
$ g++ --version
g++ (GCC) 8.5.0 20210514 (Red Hat 8.5.0-4)
```

## Abseil
安装Abseil需要依赖：
```shell
git clone https://github.com/abseil/abseil-cpp
cd abseil-cpp
# 这里使用了一个比较老版本的abseil，新的abseil版本会依赖新的C++特性
git checkout 20220623.2
mkdir build && cd build
# -DCMAKE_INSTALL_PREFIX=/usr/local最好不用不然后面google-re2依赖可能找不到某些软链
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_STANDARD=17 ..
make
make install
```

安装re2：
```
git clone https://github.com/google/re2.git
cd re2
# 安装一个老版本确保对依赖软件版本较低些
git checkout 2022-12-01
make
make install
pip install pybind11
# 依赖外围包
pip install google-re2==1.1
```

# 性能比较
执行测试代码：
```python
import re
try:
    import re2
except Exception:
    re2 = None

def setup_data():
    text = " ".join(["word"] * 100000)
    return text

def bench_findall(loops, text):
    cre = re.compile(r"\b\w+\b")
    for _ in range(loops):
        cre.findall(text)

def bench_findall_re2(loops, text):
    cre = re2.compile(r"\b\w+\b")
    for _ in range(loops):
        cre.findall(text)

if __name__ == "__main__":
    import pyperf
    runner = pyperf.Runner()
    text = setup_data()
    runner.bench_func('re.findall', bench_findall, 1, text)
    if re2:
        runner.bench_func('re2.findall', bench_findall_re2, 1, text)
```
输出结果，这里实际re.findall效率会比re2.findall来的好：
```shell
.....................
re.findall: Mean +- std dev: 51.6 ms +- 4.9 ms
.....................
re2.findall: Mean +- std dev: 1.30 sec +- 0.15 sec
```
如果将正则基线测试改成病态回溯示例：(a+)+b 在输入 a...c 上会触发大量回溯（re 后端为回溯引擎），耗时随 a 的长度呈超线性/指数增长。但re2不会出现这个情况，实际时间开销和输入成线性正比。
```python
import re
try:
    import re2
except Exception:
    re2 = None


def setup_data():
    text = "a"* 10 + "c"
    return text


def bench_findall(loops, text):
    cre = re.compile(r"(a+)+b")
    for _ in range(loops):
        cre.findall(text)


def bench_findall_re2(loops, text):
    cre = re2.compile(r"(a+)+b")
    for _ in range(loops):
        cre.findall(text)


if __name__ == "__main__":
    import pyperf
    runner = pyperf.Runner()
    text = setup_data()
    runner.bench_func('re.findall', bench_findall, 1, text)
    if re2:
        runner.bench_func('re2.findall', bench_findall_re2, 1, text)
```
```shell
.....................
re.findall: Mean +- std dev: 186 us +- 23 us
.....................
re2.findall: Mean +- std dev: 26.3 us +- 7.4 us
```
如果将`text = "a"* 10 + "c"`改成`text = "a"* 20 + "c"`，则输出是：
```shell
re.findall: Mean +- std dev: 193 ms +- 35 ms
.....................
re2.findall: Mean +- std dev: 25.0 us +- 3.5 us
```
内存开销和时间开销类似，在非病态回溯下两者开销类似，在病态回溯下，re的内存开销会暴。但因为RE2要存一些状态机结构，所以某些情况下re2会占用更大的内存。
- Python re（回溯引擎）
compile 阶段会生成一个内部的 opcodes/字节码和解析树，通常内存开销小并且与输入字符串长度成线性关系；
大多数内存/时间问题出现在匹配阶段（回溯保存状态栈导致时间/内存爆炸），不是编译阶段。
- RE2（基于 DFA/NFA）
compile 时要构建状态机、转换表等结构；这些结构对某些复杂模式可能比 re 的内部表示更大，但 RE2 的设计目标是时间/内存可控（避免指数爆炸）。
